#!/usr/bin/env Rscript

###########################################################################
#### Copyright (C) 2021 - INRAe (Fabrice Besnard, RDP)
#### This script is a free software: you can redistribute it
#### and/or modify it under the terms of the GNU General Public
#### License (GNU GPL) as published by the Free Software Foundation, either
#### version 3 of the License, or (at your option) any later version.
#### Distributed without any warranty.
###########################################################################
# started: 2021-01-05
# last edit: 2021-06-11
#Version v0

##Content:
#Functions to handle dtw results and compare them with simulated ground truths (with or without segmentation errors) generated with sim_phyllo_sources.R.

##################
##   Libraries  ##
##################
pkgTest <- function(x){
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}
pkgTest("gridExtra")

##########################
## Convert dtw results  ##
##########################
convert_dtw_results=function(my_res, seq.ref, seq.test, verbose=TRUE){
  ## DESCRIPTION: This function converts the result table (representing intervals) generated by dtw in a format similar to the format used for intervals by the R simulation scripts
  # Description of the target format (for more details, please read sim_phyllo_sources.R):
      #sequences are 1-indexed
      #output columns names will be: $PlantID, $intervals, $reference, $test, "dtw", "cost"
      #some intervals are repeated when needed to keep the alignment between the reference and test sequences
  # my_res [input]: a table containing raw dtw results with following fields:
      # $PlantID $test $reference $type $cost
  # seq.ref [input]: dataframe formated as $PlantID $angles $internodes, contains the values of the reference sequence
  # seq.test [input]: seq.test [input]: dataframe formated as $PlantID $angles $internodes, contains the values of the test sequence to be aligned against the reference sequence
  # output: a dataframe aligning indexes of the reference and test sequences in the appropriate format ($PlantID, $intervals, $reference, $test, "dtw", "cost")
  
  #Checking/reformatting Inputs
  seq.ref$PlantID=as.factor(seq.ref$PlantID)
  seq.test$PlantID=as.factor(seq.test$PlantID)
  my_res$PlantID=as.factor(my_res$PlantID)
  if (sum(levels(my_res$PlantID) %in% levels(seq.ref$PlantID)) != length(levels(my_res$PlantID)) &
      sum(levels(my_res$PlantID) %in% levels(seq.test$PlantID)) != length(levels(my_res$PlantID)) ){
    stop("Given PlantID is/are not found in all input dataframes. Check PlantID and/or input data.")
  }
  #convert all dtw "type" to upper case:
  my_res$type=toupper(my_res$type)
  
  #Intern functions
  duplicate_line=function(df, line, n){
    #DESCRIPTION: duplicate a line as many times required in a dataframe. Order is kept
    #df [input]: input dataframe
    #line [input]: index of the line to duplicate
    #n [input]: nber of times the line should be duplicated
    #output: the input dataframe modified by the function
    
    df_out=df
    df_out$index__=seq(1:nrow(df))
    for (i in 1:n){
      df_out=rbind(df_out, df_out[line,])
    }
    df_out=df_out[order(df_out$index__),]
    df_out=df_out[,1:(ncol(df_out)-1)]
    return(df_out)
  }
  
  #Modify column order: PlantID first, switch ref and test order, add +1 index, change names:
  out=cbind(my_res$PlantID, rep(NA, nrow(my_res)), my_res[,c(3,2)]+1, my_res[,c(4,5)] )
  names(out)=c("PlantID", "intervals", "reference", "test","dtw", "cost")
  #intervals will be generated for each plant hereafter
  
  #Take input PlantID as factors
  PlantID=as.factor(my_res$PlantID)
  
  #Loop over all input PlantIDs:
  for (id in levels(PlantID)){
    if (verbose){
      cat("Converting dtw results for PlantID =", id, "\n")  
    }
    out_subset=subset(out, PlantID==id)
    plant.seq.ref=subset(seq.ref, PlantID==id)
    plant.seq.test=subset(seq.test, PlantID==id)
    
    #case of a M event -> add a row before, ref duplicated and new test (an idx was missing)
    M_idx=which(out_subset$dtw == "M")
    if (length(M_idx > 0)){
      for (i in 1:length(M_idx)){
        #find how much "test" rows are missing with this merge:
        if (M_idx[i]==1){ miss.test=out_subset$test[M_idx[i]]-1 }
        else { miss.test=out_subset$test[M_idx[i]]-out_subset$test[M_idx[i]-1]-1  }
        #Introduce as many rows as necessary:
        out_subset=duplicate_line(out_subset, M_idx[i], miss.test)
        #update test index(es)
        out_subset[which(out_subset$test == out_subset$test[M_idx[i]]),]$test=seq(out_subset$test[M_idx[i]]-miss.test, out_subset$test[M_idx[i]])
        #rewrite intervals
        out_subset$intervals=seq(1:nrow(out_subset))
        #shift M_idx records
        M_idx=M_idx+miss.test
      }
    }
    
    #Case of a S event -> add a row before, new ref (idx was missing) and test is duplicated
    S_idx=which(out_subset$dtw == "S")
    if (length(S_idx > 0)){
      for (i in 1:length(S_idx)){
        #find how much "ref" rows are missing with this split:
        if (S_idx[i]==1){ miss.ref=out_subset$ref[S_idx[i]]-1 }
        else { miss.ref=out_subset$ref[S_idx[i]]-out_subset$ref[S_idx[i]-1]-1  }
        #print("nb of missing rows 'miss.ref'")
        #print(miss.ref)
        #Introduce as many rows as necessary:
        out_subset=duplicate_line(out_subset, S_idx[i], miss.ref)
        #update ref index(es)
        out_subset[which(out_subset$reference == out_subset$reference[S_idx[i]]),]$reference=seq(out_subset$reference[S_idx[i]]-miss.ref,out_subset$reference[S_idx[i]])
        #rewrite intervals
        out_subset$intervals=seq(1:nrow(out_subset))
        #shift S_idx records
        S_idx=S_idx+miss.ref
      }
    }
    
    #Case of Chops and tails: modify start/end of the table
    #Subcase of Chops (must be treated before tails to avoid irrelevant alignment of tails with chops)
    #Starting chops
    if (min(out_subset$reference, na.rm = TRUE) > 1 ){
      #Add as many lines as necessary to get back all reference indexes from 1 to the current minimum = first.ref.idx
      first.ref.idx=min(out_subset$reference, na.rm = TRUE)
      out_subset=duplicate_line(out_subset, 1, (first.ref.idx - 1) )
      #update ref index(es) in the added rows
      out_subset[1:(first.ref.idx-1),]$reference=seq(1:(first.ref.idx - 1))
      #update test index(es): they are NAs
      out_subset[1:(first.ref.idx-1),]$test=NA
      #update DTW type: they are "C" (for chops)
      out_subset[1:(first.ref.idx-1),]$dtw="C"
      #update cost: they are NAs (no cost for free-ends)
      out_subset[1:(first.ref.idx-1),]$cost=NA
      #rewrite intervals
      out_subset$intervals=seq(1:nrow(out_subset))
    }
    #Ending chops
    Nref=nrow(plant.seq.ref) #Nber of rows/intervals of the reference sequence: They should all be present in the final result table
    max_row=nrow(out_subset) #the Nber of rows of the current alignment
    # print(id)
    # print(Nref)
    # print(max_row)
    # print(out_subset)
    if (max(out_subset$reference, na.rm = TRUE) < Nref){
      #Add as many lines as necessary at the end to get back all reference indexes from the current last index (= last.ref.idx) to the true last index (=Nref) 
      last.ref.idx=max(out_subset$reference, na.rm = TRUE)
      out_subset=duplicate_line(out_subset, max_row, (Nref - last.ref.idx) ) #the number of rows has changed and is now > max_row
      #update ref index(es) in the added rows
      # print(last.ref.idx)
      # print(out_subset[which(out_subset$reference >= last.ref.idx),])
      # print(seq((last.ref.idx),Nref))
      out_subset[(max_row+1):nrow(out_subset),]$reference=(last.ref.idx+1):Nref
      #update test index(es): they are NAs
      out_subset[which(out_subset$reference > last.ref.idx),]$test=NA
      #update DTW type: they are "C" (for chops)
      out_subset[which(out_subset$reference > last.ref.idx),]$dtw="C"
      #update cost: they are NAs (no cost for free-ends)
      out_subset[which(out_subset$reference > last.ref.idx),]$cost=NA
      #rewrite intervals
      out_subset$intervals=seq(1:nrow(out_subset))
    }
    
    #Tails
    #Note: if tails and chops, tails are displaced outside (before chops for starting tails, after chops for trailing tails) 
    #subcase of starting tails: test index starts after 1 at first interval
    if (min(out_subset$test, na.rm = TRUE) > 1){
      #Add as many lines as necessary to get back all test indexes from 1 to the current minimum = first.test.idx
      first.test.idx=min(out_subset$test, na.rm = TRUE)
      out_subset=duplicate_line(out_subset, 1, (first.test.idx - 1) ) #replicate the first line as many times as needed
      #update test index(es) in the added rows
      out_subset[1:(first.test.idx - 1),]$test=seq(1,(first.test.idx - 1))
      #update reference indexes: they are NAs
      out_subset[1:(first.test.idx - 1),]$reference=NA
      #update dtw type: they are "T"
      out_subset[1:(first.test.idx - 1),]$dtw="T"
      #update cost: NA
      out_subset[1:(first.test.idx - 1),]$cost=NA
      #rewrite intervals
      out_subset$intervals=seq(1:nrow(out_subset))
    }
    #Trailing tails
    Ntest=nrow(plant.seq.test) #Nber of rows/intervals of the test sequence: they should all be present in the final result table
    max_row=nrow(out_subset) #the Nber of rows of the current alignment (Tails should be placed at the end of it)
    if (max(out_subset$test, na.rm = TRUE) < Ntest){
      #Add as many lines as necessary at the end to get back all test indexes from the current last index (= last.test.idx) to the true last index (=Ntest) 
      last.test.idx=max(out_subset$test, na.rm = TRUE)
      out_subset=duplicate_line(out_subset, max_row, (Ntest - last.test.idx) ) #replicate the last line as many times needed
      #update test index(es) in the added rows
      out_subset[(max_row+1):nrow(out_subset),]$test=(last.test.idx+1):Ntest
      #update reference indexes: they are NAs
      out_subset[(max_row+1):nrow(out_subset),]$reference=NA
      #update dtw type: they are "T"
      out_subset[(max_row+1):nrow(out_subset),]$dtw="T"
      #update cost: NA
      out_subset[(max_row+1):nrow(out_subset),]$cost=NA
      #rewrite intervals
      out_subset$intervals=seq(1:nrow(out_subset))
    }

    #replace the modifications in the final table:
    out=rbind(subset(out, PlantID!=id), out_subset)
  }#end of for loop over PlantID levels
  
  return(out)
}

#######################################
## Compare dtw align and true align  ##
#######################################
#intern sub function (to avoid checking each time with a 'if' that the selection exists, ie nrow >1)
eval_if_exist=function(sub.df, field, string){
  column=which(colnames(sub.df) == field)
  if (nrow(sub.df)>0){
    sub.df[,column]=string
    return(sub.df[,column])
  }
}

code_eval=function(df, dtw.res, true.op, ambiguous=TRUE, leniant=TRUE ){
  #Description: edit the $eval field of input dataframe df by comparing dtw prediction (dtw.res) and true result (true.op)
  #df [input]: dataframe ; typical 'test.eval' of the mother function 'evaluate_align_prediction_byplant'
  #           contains the following seven fields: test.interval / N.align / align.score / dtw.predict / dtw.true / dtw.cost / code.eval
  #dtw.res [input]: string or vector of strings ; the dtw prediction
  #true.op [input]: string or vector of strings ; the true operation
  #ambiguous [param]: TRUE/FALSE; eval is 'ambiguous' for a predicted operation that is not exactly the true operation if this true operation (necessarily complex) contains the predicted operation. 
  #leniant [param]: TRUE/FALSE; if TRUE, eval is set to 'correct' for a predicted operation that is not exactly the true operation if this true operation (necessarily complex) is ONLY a pure combination of the predicted operation.
  #[output]:dataframe df with field $eval edited. 
  #    $code.eval has 3 possible levels:
  #       -correct: predicted operation (dtw.res) corresponds to true operation (true.op), 
  #    ie. dtw.res ~ true.op, strict equality depends on parameters 'leniant'
  #       -ambiguous: predicted operation is not exactly the true operation, but is part of the combination of true operations
  #       -error: predicted operation does not correspond at all to true operation
  
  #coherence of parameter choice
  if (!ambiguous){leniant=FALSE} #leniant can only be activated if ambiguous is activated
  
  #eval the different situations:
  df[(df$dtw.predict %in% dtw.res) & (df$dtw.true %in% true.op),]$code.eval=eval_if_exist(df[(df$dtw.predict %in% dtw.res) & (df$dtw.true %in% true.op),],
                                                                                     "code.eval", "correct")
  df[(df$dtw.predict %in% dtw.res) & !(df$dtw.true %in% true.op),]$code.eval=eval_if_exist(df[(df$dtw.predict %in% dtw.res) & !(df$dtw.true %in% true.op),],
                                                                                           "code.eval", "error")
  if (ambiguous){
    #identify rows that contain the desired pattern in the true op:
    r1=grep(dtw.res, df$dtw.true)
    #identify rows that are errors
    r2=which(df$dtw.predict %in% dtw.res & !(df$dtw.true %in% true.op) ) 
    #intersect the two lists of rows
    r_ambiguous=r2[r2 %in% r1]
    #modify the df for these rows:
    df[r_ambiguous,]$code.eval=eval_if_exist(df[r_ambiguous,], "code.eval", "ambiguous")
    
    #Note: for some reason, this simple solution not working: any levels present in df$dtw.true will be grepped, even if the pattern is not in the final df-cell.
    #df[(df$dtw.predict %in% dtw.res) & !(df$dtw.true %in% true.op) & (grep(dtw.res, df$dtw.true)),]$code.eval=eval_if_exist(df[(df$dtw.predict %in% dtw.res) & !(df$dtw.true %in% true.op) & (grep(dtw.res, df$dtw.true)),],
    #                                                                                                                               "ambiguous")
    if (leniant && length(r_ambiguous)>0){
      #an 'ambiguous' eval is turn to 'correct' if the true op is a string which is only made with dtw.res
      #example: true operation 'S/SS/S' is correct for 'S' dtw.res
      
      #suppress predicted operation dtw.res from true.op string to check whether other elements remain:
      test=gsub("/","",df[r_ambiguous,]$dtw.true) #remove "/" if any
      test1=gsub(dtw.res,"", test) #remove dtw.res (e.g. "M" or "S")
      df[r_ambiguous[nchar(test1)==0],]$code.eval=eval_if_exist(df[r_ambiguous[nchar(test1)==0],], "code.eval", "correct")
    }
    
  }
  return(df)
}

## Generate a table to compare the alignment interval per interval.
#The resulting table will have the following columns:
#Column name        ->      Description
#"PlantID"          ->    Name given to the plant, not present in the table generated by the function 'evaluate_align_prediction_byplant'
#"test.interval"    ->    Index of the interval in the TEST sequence (=the sequence to be aligned against the REFERENCE sequence)
#"N.align"          ->    Number of intervals (in the REF sequence) that are aligned to the current (TEST) interval. E.g: a split aligns to several ref intervals (N.align>1); NA for 
#"align.score"      ->    Score of the above interval number prediction, range [0-1]. 1 means that numer prediction is correct, error implies a score lower than 1
#"dtw.predict"      ->    The operation predicted by dtw (can be =, ~, M, S)
#"dtw.true"         ->    The true operation simulated on TEST sequences from REFERENCE sequence
#"dtw.cost"         ->    The cost computed by the dtw program
#"code.eval"        ->    Evaluation of the operation predicted by dtw: can be "correct", "error", "ambiguous"
#"dtw.eval"         ->    Evaluation of dtw alignment (based on operation prediction and alignment score): can be "correct", "error", "ambiguous"

evaluate_align_prediction_byplant=function(dtw_align, true_align, verbose=TRUE){
  #DESCRIPTION: for one given plant, function that evaluates prediction alignment by comparing row by row the alignment provided by dtw (first input) and a known true alignment (e.g. simulation)
  #dtw_align [input]: dataframe, dwt results after reformatting with 'convert_dtw_results' function without $PlantID field
  #true_align [input]: dataframe, alignment generated by the simulation using 'segmentation_errors' function (in sim_phyllo_sources.R)
  #                              Per PlantID dataframe, contains 3 columns: $intervals, $angles, $internodes
  #                              In the output (list) from function 'segmentation_errors', the true alignment is stored as output$I  
  
  #1. compare the lengths of the sequences
  #1.1. reference
  ref.len=max(true_align$reference, na.rm = TRUE)
  if (verbose){
    if (ref.len != max(dtw_align$reference, na.rm = TRUE)){
      print("the dtw/true reference sequences do not have the same length (probable chops)")
      print(paste("true reference =", ref.len))
      print(paste("dtw reference =", max(dtw_align$reference, na.rm = TRUE))) } 
    else { print(paste("both reference sequence have", ref.len, "intervals")) }
  }
  
  #1.1. test
  test.len=max(true_align$modified, na.rm = TRUE)
  if (verbose){
    if (test.len != max(dtw_align$test, na.rm = TRUE)){
      print("the dtw/true test sequences do not have the same length")
      print(paste("initial (true) test sequence =", test.len))
      print(paste("test sequence after dtw =", max(dtw_align$test, na.rm = TRUE))) } 
    else { print(paste("both test sequences (before/after dtw) have", test.len, "intervals")) }
  }
  
  #2. parse the entire alignment
  #Initialize empty vectors of the final table
  #test=c()        #the interval
  N.align=c()     #the nber of interval to which it aligns (>1 for split)
  align.score=c() #the score of alignment. 1 if correct <1 if not
  dtw.predict=c() #the dtw type predicted
  dtw.true=c()    #the true operation
  dtw.cost=c()    #the cost computed by dtw
  
  for (i in 1:test.len){
    #print(paste("loop is at step n°",i))
    if ( !(i %in% dtw_align$test)){ #the interval of the test sequence is not in the final dtw results
      N.align=c(N.align, 0) #this test interval do not match to any reference interval
      align.score=c(align.score, NA) #No score can be applied
      dtw.predict=c(dtw.predict, "free-end") #this interval was dropped out by the dtw algorithm
      dtw.T=true_align[which(true_align$modified == i),]$dtw
      if (length(dtw.T) > 1){ #the test interval is duplicated in the ground truth table
        if ( (sum(dtw.T[1] == dtw.T )/length(dtw.T)) == 1 ){dtw.T=dtw.T[1]} #case where all duplicated intervals share the same operation 
        else { dtw.T=paste(dtw.T, collapse="/")} #if different operation exist for the same interval, they will be cat in a single value (sep by /)
      }
      dtw.true=c(dtw.true, as.character(dtw.T)) #the true operation
      dtw.cost=c(dtw.cost, NA) #no cost associated with free-ends
      } 
    else {#the interval of the test sequence is in the final dtw results
      #Compute each element for this interval:
      prediction=dtw_align[which(dtw_align$test == i), c(2,3)]
      N=nrow(prediction)
      solution=true_align[which(true_align$modified == i), c(1,2)]
      if (nrow(solution) != N){
        score=NA
      } else {
        score=sum(rowSums( prediction == solution ) / 2)/ N  
      }
      dtw.P=dtw_align[which(dtw_align$test == i),]$dtw
      if (length(dtw.P) >1){ #the test interval is duplicated in the result table
        if ( (sum(dtw.P[1] == dtw.P )/length(dtw.P)) == 1 ){dtw.P=dtw.P[1]} #case where all duplicated intervals share the same dtw operation 
        else {dtw.P=paste(dtw.P, collapse = "/")} #if different operation exist for the same interval, they will be cat in a single value (sep by /)
      }
      dtw.T=true_align[which(true_align$modified == i),]$dtw
      if (length(dtw.T) > 1){ #the test interval is duplicated in the ground truth table
        if ( (sum(dtw.T[1] == dtw.T )/length(dtw.T)) == 1 ){dtw.T=dtw.T[1]} #case where all duplicated intervals share the same operation 
        else { dtw.T=paste(dtw.T, collapse="/")} #if different operation exist for the same interval, they will be cat in a single value (sep by /)
      }
      dtw.C=mean(dtw_align[which(dtw_align$test == i),]$cost)
      
      #add current values to the entire vectors
      N.align=c(N.align, N) 
      align.score=c(align.score, score)
      dtw.predict=c(dtw.predict, as.character(dtw.P)) #this interval was dropped out by the dtw algorithm
      dtw.true=c(dtw.true, as.character(dtw.T))    #the true operation
      dtw.cost=c(dtw.cost, dtw.C) 
    }
  }
  test.eval=cbind.data.frame(test.interval=seq(1:test.len),
                             N.align,    #the nber of interval to which it aligns (>1 for split)
                             align.score, #the score of alignment. 1 if correct <1 if not
                             dtw.predict, #the dtw type predicted
                             dtw.true,    #the true operation
                             dtw.cost)
  
  #3. eval the different categories of the dtw code
  test.eval$code.eval=""
  #Note: so far, four possible categories identified by the dtw program
  #3.1. free-end
  test.eval=code_eval(test.eval, dtw.res="T", true.op="T", ambiguous=TRUE, leniant = TRUE)
  test.eval=code_eval(test.eval, dtw.res="C", true.op="C", ambiguous=TRUE, leniant = TRUE)
  #3.2. matches
  test.eval=code_eval(test.eval, dtw.res = c("~","="), true.op = c("~","="), ambiguous=FALSE)
  #3.3. merge
  test.eval=code_eval(test.eval, dtw.res = c("M"), true.op = c("M"), ambiguous=TRUE, leniant = TRUE)
  #3.4. split
  test.eval=code_eval(test.eval, dtw.res = c("S"), true.op = c("S"), ambiguous=TRUE, leniant = TRUE)
  
  #3. eval dtw prediction based on alignment (align.score) AND code (code.eval)
  test.eval$dtw.eval="error"
  test.eval[which(is.na(test.eval$align.score) & test.eval$code.eval=="correct"),]$dtw.eval=eval_if_exist(test.eval[which(is.na(test.eval$align.score) & test.eval$code.eval=="correct"),],
                                                                                                      "dtw.eval", "correct")
  test.eval[which(test.eval$align.score==1 & test.eval$code.eval=="correct"),]$dtw.eval=eval_if_exist(test.eval[which(test.eval$align.score==1 & test.eval$code.eval=="correct"),],
                                                                                               "dtw.eval", "correct")
  test.eval[which(test.eval$align.score==1 & test.eval$code.eval=="ambiguous"),]$dtw.eval=eval_if_exist(test.eval[which(test.eval$align.score==1 & test.eval$code.eval=="ambiguous"),],
                                                                                                 "dtw.eval", "ambiguous")

  return(test.eval)
}

evaluate_align_prediction=function(dtw_results, true_align, verbose=TRUE){
  # DESCRIPTION: function that loops 'evaluate_align_prediction_byplant' over several plants (PlantID)
  # dtw_results [input]: dataframe, dwt results after reformatting with 'convert_dtw_results' function above
  # true_align [input]: dataframe with [$PlantID	$reference	$modified	$dtw], typical align_interval.csv generated by Rscript test_dtw.R
  
  #Check Inputs: matching PlantIDs between the two dataframe
  dtw_results$PlantID=as.factor(dtw_results$PlantID)
  true_align$PlantID=as.factor(true_align$PlantID)
  if ( sum(levels(dtw_results$PlantID) %in% levels(true_align$PlantID)) != length(levels(dtw_results$PlantID)) ){
    missing_PlantIDs=which(!(levels(dtw_results$PlantID) %in% levels(true_align$PlantID)))
    print("Some PlantIDs in the dtw results are missing in the groundtruth input:")
    print(levels(dtw_results$PlantID)[missing_PlantIDs])
    stop("Make sure that dtw results and groudntruth correspond to the same plants. Program will stop")
  }
  
  #Loop over PlantIDs:
  compare.df=data.frame(PlantID=character(),
                        test.interval=integer(),
                        N.align=integer(),    #the nber of interval to which it aligns (>1 for split)
                        align.score=numeric(), #the score of alignment. 1 if correct <1 if not
                        dtw.predict=character(), #the dtw type predicted
                        dtw.true=character(),    #the true operation
                        dtw.cost=numeric()) #the cost computed by dtw
  
  for (plantid in levels(dtw_results$PlantID)){
    if (verbose){cat("## Starting analysis for PlantID =" , plantid,".\n")}
    dtw_plant=subset(dtw_results, PlantID==plantid) #subset dtw results
    truealign_plant=subset(true_align, PlantID==plantid) #subset true alignment
    
    compare_plant=evaluate_align_prediction_byplant(dtw_plant[,-1], truealign_plant[,-1], verbose=verbose) #make the comparison
    
    compare_plant$PlantID=plantid #add a PlantID field
    compare_plant=cbind.data.frame(compare_plant[,ncol(compare_plant)], compare_plant[,-ncol(compare_plant)]) #put if first
    #bind to all results
    compare.df=rbind(compare.df, compare_plant)
  }
  colnames(compare.df)[1]="PlantID"
  return(compare.df)
}

##################################
## summary of a dtw evaluation  ##
##################################
#Running the following script provides a digest/summary of the comprehensive analysis provided by the above function 'evaluate_align_prediction'
#The quality of the predicted alignment can be evaluated using the following 6 information and data:
        # N.ref: the number of interval in the reference sequence
        # N.test: the number of intervals in the test sequence 
        # N.dtw.align: the number of intervals aligned by the dtw (excluding "free-ends")
        # Correct.ratio: ratio of correct predictions over the total number of intervals in the test sequence (N.tests) 
        # Match.correct.ratio: Among the intervals predicted as matches, ratio of correct predictions
        # NonMatch.correct.ratio: Among the intervals not predicted as matches (Split, Merge or free-end), ratio of correct predictions

summarize_prediction_eval=function(comparison.df, true_align.df, verbose=TRUE){
  ##Description: It provides metrics to evaluate the correctness of the prediction of the several alignments of a test sequence on their respective reference sequence knowing the true alignments.
  #true_align.df [input]: dataframe with [$PlantID	$reference	$modified	$dtw], typical align_interval.csv generated by simulating paired sequences
  #comparison.df [input]: dataframe, typical output of 'evaluate_align_prediction'
  #                       Fields: "PlantID" "test.interval" "N.align" "align.score" "dtw.predict" "dtw.true" "dtw.cost" "code.eval" "dtw.eval"
  #[output]: a 7-column dataframe containing info and metrics (6 rows), one row per PlantID, the first column is the PlantID

  #Check Inputs: matching PlantIDs between the two dataframe
  comparison.df$PlantID=as.factor(comparison.df$PlantID)
  true_align.df$PlantID=as.factor(true_align.df$PlantID)
  if ( sum(levels(comparison.df$PlantID) %in% levels(true_align.df$PlantID)) != length(levels(comparison.df$PlantID)) ){
    missing_PlantIDs=which(!(levels(comparison.df$PlantID) %in% levels(true_align.df$PlantID)))
    print("Some PlantIDs in the dtw results are missing in the groundtruth input:")
    print(levels(comparison.df$PlantID)[missing_PlantIDs])
    stop("Make sure that predicted alignment results and groundtruth correspond to the same plants. Program will stop")
  }
  
  #Main body
  ##Initialize the output dataframe
  summary=data.frame(PlantID=character(),
                     N.ref=numeric(),
                     N.test=numeric(),
                     N.dtw.align=numeric(),
                     Correct.ratio=numeric(),
                     Match.correct.ratio=numeric(),
                     NonMatch.correct.ratio=numeric())
  
  for (plantid in levels(comparison.df$PlantID)){
    if (verbose){cat("## Processing PlantID =" , plantid,".\n")}
    
    comparison_plant=subset(comparison.df, PlantID==plantid) #subset comparison dataframe for the current plantid
    truealign_plant=subset(true_align.df, PlantID==plantid) #subset true alignment
    
    #Length of Reference sequence
    N.ref=max(truealign_plant$reference, na.rm = TRUE)
    #Length of test sequence
    N.test=nrow(comparison_plant)
    #Length of dtw alignment (free-ends drop values)
    N.dtw.align=N.test-sum(comparison_plant$dtw.predict=="free-end")
    #ratio of correct predictions:
    Correct.ratio=sum(comparison_plant$dtw.eval=="correct")/N.test
    #ratio of correct among matches
    Match.correct.ratio=sum(comparison_plant[comparison_plant$dtw.eval=="correct" & comparison_plant$dtw.true %in% c("~","="),]$dtw.eval=="correct")/
      nrow(comparison_plant[comparison_plant$dtw.true %in% c("~","="),])
    #ratio of correct among non-matches
    NonMatch.correct.ratio=sum(comparison_plant[comparison_plant$dtw.eval=="correct" & !(comparison_plant$dtw.true %in% c("~","=")),]$dtw.eval=="correct")/
      nrow(comparison_plant[!(comparison_plant$dtw.true %in% c("~","=")),])
    
    plant_summary=cbind.data.frame(plantid,N.ref, N.test, N.dtw.align, Correct.ratio, Match.correct.ratio, NonMatch.correct.ratio)
    summary=rbind(summary, plant_summary)
  }
  return(summary)
}

####################################
##  Summary of a dtw prediction   ##
####################################
#Scenario: the alignment prediction is considered as correct and is used to reveal the difference between a test sequence and a reference ground truth sequence. 
#In a typical pipe of automated measurement of phyllotaxis, the differences between a test and the reference ground truth are of two types:
#related to segmentation errors: the correct organs have not been identified, some test intervals are modified by split/merge operations (or correspond to free-ends) and do not match stricly to ground truth intervals
#related to measure precision: despite correct segmentation (the organ pair forming the organ are well identified), the automated measure value and the ground truth measure value are different
#the output is a dataframe containing different metrics in columns, one row per plant id.

## Description of the metrics used in the output data (column of the output dataframe):
#reminder: a 'sequence' contains two vectors: angle and internode sequences
#Note: for metrics of fields n°12,13,14 & 15, output can be expressed as raw count or ratio over the length of the reference sequence

# 1.  PlantID [character]: arbitrary id of the plant identifying both reference and test sequences
# 2.  Ref.seq.length [numeric]: total length of the reference sequence
# 3.  Test.seq.length [numeric]: total length of the test sequence
# 4.  Nb.chop.start [numeric]: nb of reference intervals chopped ("missed") at start
# 5.  Nb.chop.end [numeric]: nb of reference intervals chopped ("missed") at the end 
# 6.  Nb.tail.start [numeric]: nb of test intervals added before the first reference interval
# 7.  Nb.tail.end [numeric]: nb of test intervals added after the last reference interval
# 8.  Nb.SPLIT.event [numeric]: total number of SPLIT event predicted in the test sequence
# 9.  Nb.organs.missed.per.SPLIT [character]: integers (as many as split events) separated by commas ; for each split event, it counts the number of organs involved (ie. missed)
# 10. Nb.MERGE.event [numeric]: total number of MERGE event predicted in the test sequence
# 11. Nb.organs.added.per.MERGE [character]: integers (as many as merge events) separated by commas ; for each merge event, it counts the number of organs involved (ie. added)
# 12. TOTAL.ORGAN.MISS [numeric]: sums all the organs predicted as missed in the test sequence (source: chops at start/end and split events)
# 13. TOTAL.ORGAN.ADDED [numeric]: sums all the organs predicted as added in the test sequence (source: tails at start/end and merge events)
# 14. TOTAL.SEGMENTATION.ERROR [numeric]: sum of the two previous counts
# 15. TOTAL.MATCH [numeric]: number of test intervals matching to reference intervals without any operations (except possible index shifts) 
# 16. ANGLES.difference [numeric]: mean difference between angle values in reference and test sequence among intervals that match
# 17. ANGLES.sd [numeric]: standard deviation between angle values in reference and test sequence among intervals that match
# 18. INTERNODES.difference [numeric]: mean difference between internode values in reference and test sequence among intervals that match
# 19. INTERNODES.sd [numeric]: standard deviation between angle values in reference and test sequence among intervals that match

summarize_align_prediction=function(dtw.res, seq.ref, seq.test, count.as=c("number","ratio"), verbose=FALSE){
  #DESCRIPTION: compute metrics to assess test quality based on dtw predicted alignment
  # dtw.res [input]: dataframe, dwt results after reformatting with 'convert_dtw_results' function above
  # seq.ref [input]: dataframe formated as $PlantID $angles $internodes, contains the values of the reference sequence
  # seq.test [input]: seq.test [input]: dataframe formated as $PlantID $angles $internodes, contains the values of the test sequence to be aligned against the reference sequence
  
  #Checking/reformatting Inputs
  count.as=match.arg(count.as)
  
  seq.ref$PlantID=as.factor(seq.ref$PlantID)
  seq.test$PlantID=as.factor(seq.test$PlantID)
  dtw.res$PlantID=as.factor(dtw.res$PlantID)
  if (sum(levels(dtw.res$PlantID) %in% levels(seq.ref$PlantID)) != length(levels(dtw.res$PlantID)) &
      sum(levels(dtw.res$PlantID) %in% levels(seq.test$PlantID)) != length(levels(dtw.res$PlantID)) ){
      stop("Given PlantID is/are not found in all input dataframes. Check PlantID and/or input data.")
    }
  
  ##Main body
  #Initialize the final output dataframe
  output.df=data.frame(PlantID=character(),
                       Ref.seq.length=numeric(),
                       Test.seq.length=numeric(),
                       Nb.chop.start=numeric(), #nb of reference intervals chopped ("missed") at start
                       Nb.chop.end=numeric(), #nb of reference intervals chopped ("missed") at the end 
                       Nb.tail.start=numeric(), #nb of test intervals added before the first reference interval
                       Nb.tail.end=numeric(), #nb of test intervals added after the last reference interval
                       Nb.SPLIT.event=numeric(),
                       Nb.organs.missed.per.SPLIT=character(),
                       Nb.MERGE.event=numeric(),
                       Nb.organs.added.per.MERGE=character(),
                       TOTAL.ORGAN.MISS=numeric(),
                       TOTAL.ORGAN.ADDED=numeric(),
                       TOTAL.SEGMENTATION.ERROR=numeric(),
                       TOTAL.MATCH=numeric(),
                       ANGLES.difference=numeric(),
                       ANGLES.sd=numeric(),
                       INTERNODES.difference=numeric(),
                       INTERNODES.sd=numeric() )
  
  for (plantid in levels(dtw.res$PlantID)){
    if (verbose){cat("## Processing PlantID =" , plantid,"\n")}
    plant.seq.ref=subset(seq.ref, PlantID==plantid)
    plant.seq.test=subset(seq.test, PlantID==plantid)
    plant.dtw.res=subset(dtw.res, PlantID==plantid)
    
    #Length of sequences
    N.ref=nrow(plant.seq.ref)
    N.test=nrow(plant.seq.test)
    ref.start.idx=which(plant.dtw.res$reference == 1)
    ref.end.idx=which(plant.dtw.res$reference == N.ref)
    test.start.idx=which(plant.dtw.res$test == 1)
    test.end.idx=which(plant.dtw.res$test == N.test)
    if (verbose){print(paste("Nb interval in ref seq =", N.ref))
      print(paste("Nb interval in test seq =", N.test))}
    #Chops at Start / End
    C.idx=grep("C", plant.dtw.res$dtw)
    N.Chop.start=sum(C.idx < test.end.idx/2) #count the number of "C" in the 1st half of the alignment
    N.Chop.end=sum(C.idx > test.end.idx/2) #count the number of "C" in the 2nd half of the alignment
    #Tails at Start / End
    T.idx=grep("T", plant.dtw.res$dtw)
    N.Tail.start=sum(T.idx < ref.end.idx/2) #count the number of "T" in the 1st half of the alignment
    N.Tail.end=sum(T.idx > ref.end.idx/2) #count the number of "C" in the 2nd half of the alignment
    
    #Internal errors of segmentation
    if (nrow(plant.dtw.res[plant.dtw.res$dtw %in% c("~","="),])>0){
      N.match=nrow(plant.dtw.res[plant.dtw.res$dtw %in% c("~","="),])
      sub.match=plant.dtw.res[plant.dtw.res$dtw %in% c("~","="),]
    }
    #Splits
    if (nrow(plant.dtw.res[plant.dtw.res$dtw=="S",])>0){
      sub.S=plant.dtw.res[plant.dtw.res$dtw=="S",]
      N.S.event=nrow(sub.S[!duplicated(sub.S$test),])
      S.event.test.idx=sub.S[!duplicated(sub.S$test),]$test
      N.organs.missed=c()
      if (length(S.event.test.idx)>0){
        for (i in 1:length(S.event.test.idx)){
          missed=length(sub.S[sub.S$test==S.event.test.idx[i],]$reference)-1
          N.organs.missed=c(N.organs.missed, missed) }
      } else { N.organs.missed=0 }
    } else {
      N.S.event=0
      N.organs.missed=0
    }
    
    #Merge
    if (nrow(plant.dtw.res[plant.dtw.res$dtw=="M",])>0){
      sub.M=plant.dtw.res[plant.dtw.res$dtw=="M",]
      N.M.event=nrow(sub.M[!duplicated(sub.M$reference),])
      M.event.ref.idx=sub.M[!duplicated(sub.M$reference),]$reference
      N.organs.added=c()
      if (length(M.event.ref.idx)>0){
        for (i in 1:length(M.event.ref.idx)){
          added=length(sub.M[sub.M$reference==M.event.ref.idx[i],]$test)-1
          N.organs.added=c(N.organs.added, added) }
      } else { N.organs.added=0}
    } else {
      N.M.event=0 
      N.organs.added=0 }
    
    #Precision of angles
    angles.diff=plant.seq.ref$angles[sub.match$reference]-plant.seq.test$angles[sub.match$test]
    #Precision of internodes
    internodes.diff=plant.seq.ref$internodes[sub.match$reference]-plant.seq.test$internodes[sub.match$test]
    
    #bind all data together in a row for the current plant
    plant.output=cbind.data.frame(PlantID=plantid,
                               Ref.seq.length=N.ref,
                               Test.seq.length=N.test,
                               Nb.chop.start=N.Chop.start,
                               Nb.chop.end=N.Chop.end,
                               Nb.tail.start=N.Tail.start,
                               Nb.tail.end=N.Tail.end,
                               Nb.SPLIT.event=N.S.event,
                               Nb.organs.missed.per.SPLIT=paste(N.organs.missed,collapse = ","),
                               Nb.MERGE.event=N.M.event,
                               Nb.organs.added.per.MERGE=paste(N.organs.added,collapse = ","),
                               TOTAL.ORGAN.MISS=N.Chop.start+N.Chop.end+sum(N.organs.missed),
                               TOTAL.ORGAN.ADDED=N.Tail.start+N.Tail.end+sum(N.organs.added),
                               TOTAL.SEGMENTATION.ERROR=N.Chop.start+N.Chop.end+sum(N.organs.missed)+N.Tail.start+N.Tail.end+sum(N.organs.added),
                               TOTAL.MATCH=N.match,
                               ANGLES.difference=mean(angles.diff),
                               ANGLES.sd=sd(angles.diff),
                               INTERNODES.difference=mean(internodes.diff),
                               INTERNODES.sd=sd(internodes.diff)
    )
    
    if (count.as=="ratio"){
      plant.output[,c(12,13,14,15)]=plant.output[,c(12,13,14,15)]/N.ref
    }
    
    #bind this row to the final output dataframe
    output.df=rbind(output.df, plant.output)
  }
  
  return(output.df)
}