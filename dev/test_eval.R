#Created 2021-01-05
#last edit 2022-06-22

local.repo="~/Documents/RDP/MyProjects/ROMI/Data/Eval_AnglesAndInternodes/" #add the final '/'
setwd(paste0(local.repo, "tests"))
#setwd(paste0(local.repo, "docker_sandbox"))
source(paste0(local.repo, "Phyllotaxis-sim-eval/source/sim_phyllo_sources.R"))
source(paste0(local.repo, "Phyllotaxis-sim-eval/source/plot_sequences_sources.R"))
source(paste0(local.repo, "Phyllotaxis-sim-eval/source/eval_dtw_sources.R"))

###############################
#1. simulation of sequences  ##
###############################
#Description:
#-a reference sequence (seq.ref) and a test sequence (seq.test) will be generated
#-Tables of alignment (of interval and organs) between ref & test will be generated
#-Divergences between ref & test come either from segmentation errors, permutations or noise on values
#-Different situations can be simulated: divergences from initial sequences or comparison of two parallel measures (e.g. manual/computer) 

###
#source="re-use data" -> sequences generated before (e.g. using Rscript 'test_dtw.R' or 'simul_data.R'), can accept several plants.
                       # so it's reproducible (example: a previous dtw align prediction on the same data can be re-used)
#source="new single plant" -> a new unique and custom ref/test sequences will be generated (randomness), dtw need to be rerun 

source="new single plant" #"re-use data" #"new single plant"

if (source == "re-use data"){
  #Generate all data needed from input files previously generated by the automated script 'test_dtw.R'
  seqs=read.csv("/home/fabfab/Documents/RDP/MyProjects/ROMI/Data/Eval_AnglesAndInternodes/docker_sandbox/reference_sequences.csv")
  colnames(seqs)[3]="internodes" #fix the capital I for internodes
  Ialign=read.csv("/home/fabfab/Documents/RDP/MyProjects/ROMI/Data/Eval_AnglesAndInternodes/docker_sandbox/align_intervals.csv")
  Oalign=read.csv("/home/fabfab/Documents/RDP/MyProjects/ROMI/Data/Eval_AnglesAndInternodes/docker_sandbox/align_organs.csv")
  tests=read.csv("/home/fabfab/Documents/RDP/MyProjects/ROMI/Data/Eval_AnglesAndInternodes/docker_sandbox/test_sequences.csv")
  colnames(tests)[3]="internodes"} else {
  
  ## Initial sequence (e.g. biological real values)
  ##Case1: Completely simulated values
  N1=24
  alpha=137.5
  a_sd=18.5 #biological/natural gaussian noise on angle values
  i_Gsd=0.8 #biological/natural gaussian noise on internode values
  i_noise_pct=75 #scale the biological/natural noise on internode relative to the average internode length
  seq=make_refseq(N=N1, alpha=alpha, a_sd=a_sd, 
                  i_Gsd=i_Gsd, i_noise_pct=i_noise_pct)
  listN1=make_align_list(N1)
  #Case2: Import sequence values directly from a file
  #seq=read.csv("reference_sequences.csv")
  
  #####
  ##Choosing a Scenario to affect one initial sequence
  #####
  ##Main parameters of the scenario
  seg_errors=TRUE #whether the initial seq will be affected or not by segmentation errors
  permutation=FALSE #whether close organs can be permuted in the test sequence only
  Noise_or_Measures="Noise" #[Noise or Measures]"Noise": test sequence is derived from ref seq with noise ; "measures": both ref and test sequences are a measure (with "noise") a the same sequence.
  
  #Other parameters linked to main parameters
  ## Segmentation Errors: 
  if (seg_errors){
    #Examples of segmentation errors
    GAIN=c(3,4,15) # GAIN=c(3,3,8)
    LOSS=c(1,2,18,23,24,25) # LOSS=c(3,6) #LOSS=c(21,22,23,24)

    #Note: overlapping position (merge/split)
    # GAIN=c(15)
    # LOSS=c(15)
    
    #Note: test with chops at both ends
    # GAIN=c(10,15)
    # LOSS=c(1,2,3,8,18,24:26)
    
    #Note: test with tails at ends + chop the end of the ref
    # GAIN=c(27,27,27)
    # LOSS=c(24,25,26)
    
    #Note: test with tails at ends + chop the end of the ref
    # GAIN=c(1,1,1)
    # LOSS=c(1,2,3)
    
    #Note: test with tails at both ends
    # GAIN=c(1,1,10,15,27,27,27)
    # LOSS=c(3,8,18)
    
    # #Note: test with overlapping tails & chops
    # GAIN=c(1,1,1,2,10,15,27,27,27,27,27)
    # LOSS=c(1,2,3,8,18, 24, 25, 26)
    
    # #Note: Isolated errors in the middle
     # GAIN=c(10,15)
     # LOSS=c(8,18)
    
    #Note: Random segmentation errors
    # nb_gain=2 #choose the nber of organs gained
    # #nb_loss=3 #choose nber of organs lost
    # GAIN=round(runif(nb_gain,min=1, max=(N1+2)), digits = 0)
    # GAIN=GAIN[order(GAIN)]
    # LOSS=round(runif(nb_loss,min=1, max=N1+1), digits = 0)
    # LOSS=LOSS[order(LOSS)]
    
    #Note: it also possible to define GAIN and LOSS as null (equivalent to setting seg_errors=FALSE)
    #GAIN=NULL
    #LOSS=NULL
  }
  if (Noise_or_Measures == "Noise"){
    sd_noise_level = c(0.25, 0.25)
    sd_noise_scale = "mean" # "sd", "mean" or absolute
    mean_noise_bias = c(0, 0)
  }
  if (permutation){
    #Permutation will be applied to each possible situations depending on selected scenario: measurement (hence only automated measurement), noisy seq, seq with only segmentation errors
    permut_length=2 #maximum length (in mm) of an internode whose organ pair is susceptible to be permuted
    permut_proba=1 #proba to make a permut when it's possible
  }
  if (Noise_or_Measures == "Measures"){
    #With a measure
    manual_anoise_sd=6 #(in degree, noise with gaussian distrib. of zero mean)
    manual_inoise_sd=0.5 #(in mm, noise with gaussian distrib. of zero mean)
    aut_anoise_sd=60 #(in degree, noise with gaussian distrib. of zero mean) -> x10 manual
    aut_inoise_sd=10 # -> x 10 manual
    sd_noise_scale = "absolute" # ["sd", "mean" or "absolute"]
  }
  
  #####
  ##Generating the sequences based on selected parameters & scenario
  ###### 
  #(run)
  if (Noise_or_Measures == "Measures"){
    #With a measure
    seq.ref=make_measure(seq, anoise_sd = manual_anoise_sd, inoise_sd = manual_inoise_sd, 
                         noise.scale = sd_noise_scale)
    seq.aut=make_measure(seq, anoise_sd = aut_anoise_sd, inoise_sd = aut_inoise_sd, 
                         noise.scale = sd_noise_scale)
    
    if (seg_errors){
      seq.test=segmentation_errors(seq.aut,listN1,
                                   organ_gain=GAIN,
                                   organ_loss=LOSS) }
    else {
      seq.test=list(seq.aut, listN1$Ialign, listN1$Oalign)
      names(seq.test)=c("values", "I", "O")}
    
    if (permutation){
      seq.test=simple_measure_permutation(seq.test$values, align.list = list(seq.test$I, seq.test$O),
                                          i_threshold = permut_length, proba = permut_proba, verbose = TRUE )
    }
    
  } else if (Noise_or_Measures == "Noise") {
    seq.ref=seq
    seq.noise=make_measure(seq, anoise_sd = sd_noise_level[1], inoise_sd = sd_noise_level[2],
                           noise.scale = sd_noise_scale, 
                           anoise.mean = mean_noise_bias[1], inoise.mean = mean_noise_bias[2])
    if (seg_errors){
      seq.test=segmentation_errors(seq.noise,listN1,
                                   organ_gain=GAIN,
                                   organ_loss=LOSS) }
    else {
      seq.test=list(seq.noise, listN1$Ialign, listN1$Oalign)
      names(seq.test)=c("values", "I", "O")}
    
    if (permutation){
      seq.test=simple_measure_permutation(seq.test$values, align.list = list(seq.test$I, seq.test$O),
                                          i_threshold = permut_length, proba = permut_proba, verbose = TRUE )
    }
  } else {
    #Without noise nor measure  
    seq.ref=seq
    
    if (seg_errors){
      seq.test=segmentation_errors(seq.ref,listN1,
                                   organ_gain=GAIN,
                                   organ_loss=LOSS) }
    else {
      seq.test=list(seq.ref, listN1$Ialign, listN1$Oalign) 
      names(seq.test)=c("values", "I", "O") }
    
    if (permutation){
      seq.test=simple_measure_permutation(seq.test$values, align.list = list(seq.test$I, seq.test$O),
                                          i_threshold = permut_length, proba = permut_proba, verbose = TRUE )
    }
  }
  print_info(seg_errors=seg_errors, permutation = permutation, Noise_or_Measures = Noise_or_Measures)
  
  ######
  #Plotting for visual check
  #####
  multiseq_plot(list(seq.ref, seq.test$values), align.df = seq.test$I, title="R simulation / ground truth")
  
  #####
  #2. write out tables (reference and test values for angles/internodes)
  #####
  seq.ref.w=cbind.data.frame(plantID=rep("MyPlant", nrow(seq.ref)), 
                             seq.ref[,c(2,3)])
  colnames(seq.ref.w)=c("PlantID", "angles", "Internodes")
  seq.test.w=cbind.data.frame(plantID=rep("MyPlant", nrow(seq.test$values)), 
                              seq.test$values[,c(2,3)])
  colnames(seq.test.w)=c("PlantID", "angles", "Internodes")
  
  write.csv(seq.ref.w, file="reference_sequences.csv",row.names = FALSE)
  write.csv(seq.test.w, file="test_sequences.csv",row.names = FALSE)
  
  #Re-assign data to homogenize data between:
  #-single plant scenario
  #-multiple plants generated using a file and the automated script 'test_dtw.R'
  seqs=read.csv("reference_sequences.csv")
  colnames(seqs)[3]="internodes" #fix the capital I for internodes
  Ialign=seq.test$I
  Ialign$PlantID="MyPlant"
  Ialign=cbind(PlantID=Ialign$PlantID,Ialign[,-ncol(Ialign)])
  Oalign=seq.test$O
  Oalign$PlantID="MyPlant"
  Oalign=cbind(PlantID=Oalign$PlantID, Oalign[,-ncol(Oalign)])
  tests=read.csv("test_sequences.csv")
  colnames(tests)[3]="internodes"
  
  #Clean data
  rm(seq)
  rm(seq.ref)
  rm(seq.ref.w)
  rm(seq.test)
  rm(seq.test.w)
}

#Plotting for visual check before running dtw (if single plant only):
multiseq_plot(list(seqs, tests), align.df = Ialign, title="test")
#Note: plotting now accept wider format (no interval columns) and variations in case of angles/internodes
seq2=seqs
colnames(seq2)=c("a", "ANGLES", "INTERNODES")
multiseq_plot(list(seq2, tests), align.df = Ialign, title="test simulated data")

#####
#2. run dtw... (outside this script)
#####
#Notes for run
#Activate conda
#source ~/softwares/miniconda3/bin/activate
#conda activate romi
#Then dtw program:
#dir=~/Documents/RDP/MyProjects/ROMI/Data/Eval_AnglesAndInternodes/tests
#align_csv_database.py ${dir}/reference_sequences.csv ${dir}/test_sequences.csv dtwtest

#####
#3. Import results
#####
#compatible with multiple PlantIDs:
data=read.csv("smdtw_result.csv", header=TRUE)
data=read.csv("dtwtest_result.csv", header=TRUE)
#data=read.csv("3dexplorer_example_result.csv", header=TRUE)
#data=read.csv("/home/fabfab/Documents/RDP/MyProjects/ROMI/Data/Eval_AnglesAndInternodes/tests/testbash/testbash3_result.csv", header=TRUE)

#####
#4. convert data and plot prediction results
#####
#compatible with multiple PlantIDs:
dtw_results=convert_dtw_results(data, seq.ref = seqs, seq.test = tests)

#Plot prediction versus solution (saved by default as a pdf entitled 'Compare_Prediction_Plots.pdf')
compare_plots(seq.ref=seqs, seq.test=tests, true.align=Ialign, dtw.results = dtw_results)

#Note: select only a few plant for the plot with their PlantID:
compare_plots(seq.ref=seqs, seq.test=tests, true.align=Ialign, dtw.results = dtw_results,
              PlantID =c("Plant#1", "Plant#2"),  PDF=TRUE, pdf.name = "test.pdf", verbose = TRUE)
compare_plots(seq.ref=seqs, seq.test=tests, true.align=Ialign, dtw.results = dtw_results,
              PlantID ="MyPlant",  PDF=FALSE, verbose = TRUE)

#####
#5. Evaluate the realignment prediction made by sm-dtw
#####
#When ground truth is available: compare dtw prediction with ground truth and Assess dtw prediction interval by interval
#Compatible with Multiple PlantIDs:
prediction_eval=evaluate_align_prediction(dtw_results, Ialign, verbose = FALSE)
View(prediction_eval)

#Plot the results of the evaluation to highlight possible errors of sm-dtw
#For one plant only: select the plantid
id="MyPlant"
dtw.res.align=dtw_results[dtw_results$PlantID==id, ]
dtw.res.align=cbind.data.frame(reference=dtw.res.align$reference, modified=dtw.res.align$test, dtw=dtw.res.align$dtw)
multiseq_plot(list(seqs, tests), align.df = dtw.res.align , prediction.eval = prediction_eval,
              id.names = c("sim-data", "dtw_realigned_prediction"),
              title=paste0("PlantID: ", id, "/ Eval sm-dtw prediction"))

#integrate the highlight with a side/side comparison of groundtruth and predicted alignment:
compare_plots(seq.ref=seqs, seq.test=tests, 
              true.align=Ialign, dtw.results = dtw_results,  prediction.eval= prediction_eval)

#####
#6. dtw Cost study
#####
require(ggplot2)
ggplot(data=prediction_eval, aes(dtw.cost, fill=dtw.eval))+
  geom_histogram(position = "dodge", binwidth = 0.05)

#####
#7. Summary of the dtw-prediction per plant 
#####
summarize_prediction_eval(prediction_eval, Ialign, verbose=FALSE)

#max(dtw_results$test, na.rm = TRUE) #how many intervals are kept by dtw in the alignment ?
#sum(comp$dtw.eval=="correct") #how many intervals are correctly aligned and encoded ?

#####
#8. Use sm-dtw to evaluate a test sequence against a reference sequence
#####
#compatible with multiple PlantIDs:
dtw_results=convert_dtw_results(data, seq.ref = seqs, seq.test = tests)

#No ground truth: just plot the result for a plant
id="Col0_26_10_2018_B"   # "Col0_26_10_2018_B"# "Col0_12_10_2018_E" #"MyPlant"
dtw.res.align=dtw_results[dtw_results$PlantID==id, ]
dtw.res.align=cbind.data.frame(reference=dtw.res.align$reference, modified=dtw.res.align$test, dtw=dtw.res.align$dtw)
seqs.plant=seqs[seqs$PlantID==id,]
tests.plant=tests[tests$PlantID==id,]
multiseq_plot(list(seqs.plant, tests.plant), align.df = dtw.res.align , prediction.eval = NULL,
              id.names = c("manual", "automated"),
              title=paste0("PlantID: ", id, "/ sm-dtw prediction"))


multiseq_plot(list(seqs, tests), align.df = dtw.res.align , prediction.eval = prediction_eval,
              id.names = c("sim-data", "dtw_realigned_prediction"),
              title=paste0("PlantID: ", id, "/ Eval sm-dtw prediction"))
#when no ground truth: trust dtw alignment and assess how good the test sequence is (considering that dtw is correct)
summarize_align_prediction(dtw_results, seqs, tests, count.as = "number")

#Debug
testplant="Plant#2"
testplant.res=subset(dtw_results, PlantID==testplant)
testplant.refseq=subset(seqs, PlantID==testplant)
testplant.testseq=subset(tests, PlantID==testplant)

summarize_align_prediction(testplant.res, testplant.refseq, testplant.testseq, count.as = "number")


#######
#Other -> Study of free-ends
#####
#Starting sequence ? I have not recorded it... (cf ppt?)
#Example1 (chops)
free_ends=c("(0,1)", "(0,2)", "(1,2)", "(1,3)", "(2,3)", "(2,4)", "(2,5)", "(3,5)", "(3,6)",
            "(3,7)", "(4,7)", "(5,7)", "(5,8)", "(5,9)", "(5,10)")
norm.cost=c(0.240, 0.235, 0.195, 0.183, 0.168, 0.168, 0.162, 0.093, 0.091, 0.073, 0.073,0.073,0.073,0.073,0.073)
#data got from dwt results after run and copy-pasted here

#Example2 (tails)
free_ends=c("(0,1)", "(0,2)", "(1,2)", "(1,3)", "(2,3)", "(2,4)", "(2,5)", "(3,5)", "(3,6)",
            rep("na",15), "(12,12)")
norm.cost=c(0.111, 0.109, 0.109, 0.108, 0.089, 0.083, 0.083, 0.083, 0.083, rep(NA, 15), 0.076)
N.organs=c(14, 15, 15, 20, 24, 26, 25, 25, 25, rep(NA, 15), 18)
N.output=c(29, 28, 28, 27, 27, 26, 25, 25, 25, rep(NA, 15), 18)
#data got from dwt results after run and copy-pasted here

free_end_effect=cbind.data.frame(free_ends, norm.cost, N.organs, N.output)

require(gridExtra)
p1=ggplot(data=free_end_effect, aes(x=1:length(norm.cost), y=norm.cost))+
  geom_point()+geom_line()+
  scale_y_continuous(limits=c(0,max(norm.cost)))+
  scale_x_continuous(breaks=1:length(norm.cost), labels=free_ends)+
  geom_hline(yintercept=0.083, lty="dashed")+
  xlab("free-ends")+ylab("Normlized cost (dtw)")

p2=ggplot(data=free_end_effect, aes(x=1:length(norm.cost), y=N.organs))+
  geom_point()+geom_line()+
  scale_y_continuous(limits=c(0,29))+
  scale_x_continuous(breaks=1:length(norm.cost), labels=free_ends)+
  xlab("free-ends")+ylab("Nb of correct ")

p3=ggplot(data=free_end_effect, aes(x=1:length(norm.cost), y=N.output))+
  geom_point()+geom_line()+
  scale_y_continuous(limits=c(0,29))+
  scale_x_continuous(breaks=1:length(norm.cost), labels=free_ends)+
  xlab("free-ends")+ylab("Nb of organs output by dtw")

grid.arrange(p1,p2,p3, nrow=3)
